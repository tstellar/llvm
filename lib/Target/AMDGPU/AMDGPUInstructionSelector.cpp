//===- AMDGPUInstructionSelector.cpp ----------------------------*- C++ -*-==//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the InstructionSelector class for
/// AMDGPU.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "AMDGPUInstructionSelector.h"
#include "AMDGPUInstrInfo.h"
#include "AMDGPURegisterBankInfo.h"
#include "AMDGPURegisterInfo.h"
#include "AMDGPUSubtarget.h"
#include "llvm/CodeGen/MachineBasicBlock.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstr.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/IR/Type.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/raw_ostream.h"

#define DEBUG_TYPE "amdgpu-isel"

using namespace llvm;

AMDGPUInstructionSelector::AMDGPUInstructionSelector(
    const SISubtarget &STI, const AMDGPURegisterBankInfo &RBI)
    : InstructionSelector(), TII(*STI.getInstrInfo()),
      TRI(*STI.getRegisterInfo()), RBI(RBI), AMDGPUASI(STI.getAMDGPUAS()) {}

bool
AMDGPUInstructionSelector::constrainGenericOpReg(MachineRegisterInfo &MRI,
                                                 unsigned Reg) const {
  const RegisterBank *RegBank = RBI.getRegBank(Reg, MRI, TRI);
  unsigned Size = RBI.getSizeInBits(Reg, MRI, TRI);

  const TargetRegisterClass *RC = nullptr;
  switch (Size) {
  default: break;
  case 32:
    RC =  RegBank->getID() == AMDGPU::SGPRRegBankID ? &AMDGPU::SGPR_32RegClass :
                                                      &AMDGPU::VGPR_32RegClass;
    break;
  case 64:
    RC =  RegBank->getID() == AMDGPU::SGPRRegBankID ? &AMDGPU::SGPR_64RegClass :
                                                      &AMDGPU::VReg_64RegClass;
    break;
  case 96:
    if (RegBank->getID() == AMDGPU::SGPRRegBankID)
      return false;
    RC = &AMDGPU::VReg_96RegClass;
    break;
  case 128:
    RC =  RegBank->getID() == AMDGPU::SGPRRegBankID ? &AMDGPU::SGPR_128RegClass :
                                                      &AMDGPU::VReg_128RegClass;
    break;
  case 256:
    RC =  RegBank->getID() == AMDGPU::SGPRRegBankID ? &AMDGPU::SReg_256RegClass :
                                                      &AMDGPU::VReg_256RegClass;
    break;
  }

  if (!RC)
    return false;

  RBI.constrainGenericRegister(Reg, *RC, MRI);
  return true;
}

bool AMDGPUInstructionSelector::selectCOPY(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();
  I.setDesc(TII.get(TargetOpcode::COPY));
  dbgs() << "Contraining: " << I << '\n';
  return constrainGenericOpReg(MRI, I.getOperand(0).getReg());
}

MachineOperand
AMDGPUInstructionSelector::getSubOperand64(MachineOperand &MO,
                                           unsigned SubIdx) const {

  MachineInstr *MI = MO.getParent();
  MachineBasicBlock *BB = MO.getParent()->getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();
  unsigned DstReg = MRI.createVirtualRegister(&AMDGPU::SGPR_32RegClass);

  if (MO.isReg()) {
    unsigned ComposedSubIdx = TRI.composeSubRegIndices(MO.getSubReg(), SubIdx);
    unsigned Reg = MO.getReg();
    BuildMI(*BB, MI, MI->getDebugLoc(), TII.get(AMDGPU::COPY), DstReg)
            .addReg(Reg, 0, ComposedSubIdx);

    return MachineOperand::CreateReg(DstReg, MO.isDef(), MO.isImplicit(),
                                     MO.isKill(), MO.isDead(), MO.isUndef(),
                                     MO.isEarlyClobber(), 0, MO.isDebug(),
                                     MO.isInternalRead());
  }

  assert(MO.isImm());

  APInt Imm(64, MO.getImm());

  switch (SubIdx) {
  default:
    llvm_unreachable("do not know to split immediate with this sub index.");
  case AMDGPU::sub0:
    return MachineOperand::CreateImm(Imm.getLoBits(32).getSExtValue());
  case AMDGPU::sub1:
    return MachineOperand::CreateImm(Imm.getHiBits(32).getSExtValue());
  }
}

bool AMDGPUInstructionSelector::selectG_ADD(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();
  unsigned Size = RBI.getSizeInBits(I.getOperand(0).getReg(), MRI, TRI);
  unsigned DstLo = MRI.createVirtualRegister(&AMDGPU::SReg_32RegClass);
  unsigned DstHi = MRI.createVirtualRegister(&AMDGPU::SReg_32RegClass);

  if (Size != 64)
    return selectSimple(I);

  DebugLoc DL = I.getDebugLoc();

  MachineOperand Lo1(getSubOperand64(I.getOperand(1), AMDGPU::sub0));
  MachineOperand Lo2(getSubOperand64(I.getOperand(2), AMDGPU::sub0));

  MachineInstr *AddLo = BuildMI(*BB, &I, DL, TII.get(AMDGPU::S_ADD_U32), DstLo)
          .add(Lo1)
          .add(Lo2);

//  if (!constrainSelectedInstRegOperands(*AddLo, TII, TRI, RBI))
//    return false;

  MachineOperand Hi1(getSubOperand64(I.getOperand(1), AMDGPU::sub1));
  MachineOperand Hi2(getSubOperand64(I.getOperand(2), AMDGPU::sub1));

  MachineInstr *AddHi = BuildMI(*BB, &I, DL, TII.get(AMDGPU::S_ADDC_U32), DstHi)
          .add(Hi1)
          .add(Hi2);

//  if (!constrainSelectedInstRegOperands(*AddHi, TII, TRI, RBI))
//    return false;

  BuildMI(*BB, &I, DL, TII.get(AMDGPU::REG_SEQUENCE), I.getOperand(0).getReg())
          .addReg(DstLo)
          .addImm(AMDGPU::sub0)
          .addReg(DstHi)
          .addImm(AMDGPU::sub1);


  if (!constrainGenericOpReg(MRI, I.getOperand(0).getReg()))
    return false;

  I.eraseFromParent();
  return true;
}

bool AMDGPUInstructionSelector::selectG_ASHR(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();
  unsigned Dst = I.getOperand(0).getReg();
  unsigned Size = RBI.getSizeInBits(Dst, MRI, TRI);

  unsigned Opcode;
  // FIXME: Handle pre-VI
  switch (Size) {
  default:
    return false;
  case 32:
    Opcode = AMDGPU::V_ASHRREV_I32_e64;
    break;
  case 64:
    Opcode = AMDGPU::V_ASHRREV_I64;
    break;
   }

  const DebugLoc &DL = I.getDebugLoc();
  // FIXME: We should find a way to legalize this, so that operand 2
  // is 32-bit.
  MachineInstr *New = BuildMI(*BB, &I, DL, TII.get(Opcode), Dst)
                              .addReg(I.getOperand(2).getReg(), 0, AMDGPU::sub0)
                              .add(I.getOperand(1));

  bool Ret = constrainSelectedInstRegOperands(*New, TII, TRI, RBI);
  I.eraseFromParent();
  return Ret; 
}

bool AMDGPUInstructionSelector::selectG_BR(MachineInstr &I) const {
  I.setDesc(TII.get(AMDGPU::S_BRANCH));
  return true;
}

bool AMDGPUInstructionSelector::selectG_BRCOND(MachineInstr &I) const {

  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();
  const DebugLoc &DL = I.getDebugLoc();
  unsigned CondReg = I.getOperand(0).getReg();
  const RegisterBank *OpBank = RBI.getRegBank(CondReg, MRI, TRI);

  if (OpBank->getID() == AMDGPU::SGPRRegBankID) {
    const MachineInstr *Extract = MRI.getVRegDef(CondReg);
    if (Extract && Extract->getOpcode() == AMDGPU::G_EXTRACT) {
      MachineInstr *If = MRI.getVRegDef(Extract->getOperand(1).getReg());
      if (If && If->getOpcode() == AMDGPU::G_INTRINSIC_W_SIDE_EFFECTS &&
          If->getOperand(1).isIntrinsicID() &&
          If->getOperand(1).getIntrinsicID() == Intrinsic::amdgcn_if) {
        unsigned IfDstReg = If->getOperand(0).getReg();

        // Find the 64-bit part of the If return value, which represents the
        // exec mask.
        for (const MachineInstr &Use : MRI.use_instructions(IfDstReg)) {
          if (Use.getOpcode() != AMDGPU::G_EXTRACT ||
              Use.getOperand(2).getImm() != 64)
            continue;
          unsigned ExecMask = Use.getOperand(0).getReg();
          MachineInstr *New = BuildMI(*BB, &I, DL, TII.get(AMDGPU::SI_IF),
                                       ExecMask)
                                       .add(If->getOperand(2))
                                       .add(I.getOperand(1));
          bool Ret = constrainSelectedInstRegOperands(*New, TII, TRI, RBI);
          I.eraseFromParent();
          If->eraseFromParent();
          return Ret; 
        }
      }
    }
  }

  if (OpBank->getID() != AMDGPU::SCCRegBankID)
    return false;

  MachineInstr *New = BuildMI(*BB, &I, DL, TII.get(AMDGPU::S_CBRANCH_SCC1))
                              .add(I.getOperand(1));
  bool Ret = constrainSelectedInstRegOperands(*New, TII, TRI, RBI);
  I.eraseFromParent();
  return Ret; 

}

static int64_t getConstant(const MachineInstr *MI) {
  return MI->getOperand(1).getCImm()->getSExtValue();
}

static bool isConstant(const MachineOperand &MO, int64_t &C) {
  const MachineFunction *MF = MO.getParent()->getParent()->getParent();
  const MachineRegisterInfo &MRI = MF->getRegInfo();
  const MachineInstr *Def = MRI.getVRegDef(MO.getReg());
  if (Def->getOpcode() == AMDGPU::G_CONSTANT) {
    C = Def->getOperand(1).getCImm()->getSExtValue();
    return true;
  }

  if (Def->getOpcode() == AMDGPU::COPY)
    return isConstant(Def->getOperand(1), C);

  return false;
}

bool
AMDGPUInstructionSelector::selectG_EXTRACT_VECTOR_ELT(MachineInstr &I) const {
  dbgs() << "G_EXTRACT_VECTOR_ELT: " << I << '\n';
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();
  DebugLoc DL = I.getDebugLoc();
  int64_t SubRegIdx;
  unsigned DstReg = I.getOperand(0).getReg();
  unsigned SrcReg = I.getOperand(1).getReg();
  unsigned SrcSize = RBI.getSizeInBits(SrcReg, MRI, TRI);

  dbgs() << "Check if const\n";
  if (!isConstant(I.getOperand(2), SubRegIdx)) {
          dbgs() << "No\n";
    unsigned Opcode;
    switch (SrcSize) {
    default:
      return false;
    case 256:
      Opcode = AMDGPU::SI_INDIRECT_SRC_V8;
      break;
    } 

          dbgs() << " Create new\n";
    // TODO: Add custom pattern for selecting immediate.
    MachineInstr *New = BuildMI(*BB, I, DL, TII.get(Opcode), DstReg)
                                .addReg(SrcReg)
                                .addReg(I.getOperand(2).getReg())
                                .addImm(0);
    bool Ret = constrainSelectedInstRegOperands(*New, TII, TRI, RBI);
    I.eraseFromParent();
    return Ret;
  }

  dbgs() << "Yes\n";
  dbgs() << "SubregIdx = " << SubRegIdx << '\n';
  SubRegIdx = TRI.getSubRegFromChannel(SubRegIdx);
  BuildMI(*BB, &I, DL, TII.get(AMDGPU::COPY), DstReg)
          .addReg(I.getOperand(1).getReg(), 0, SubRegIdx);

  I.eraseFromParent();
  dbgs() << "Constrain\n";
  return constrainGenericOpReg(MRI, DstReg);
}

bool AMDGPUInstructionSelector::selectG_GEP(MachineInstr &I) const {
  return selectG_ADD(I);
}

bool AMDGPUInstructionSelector::selectG_ICMP(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();
  DebugLoc DL = I.getDebugLoc();

  if (hasOnlySGPROperands(I, MRI)) {
    unsigned Opcode = getSALUOpcode(I);
    if (Opcode == AMDGPU::INSTRUCTION_LIST_END)
      return false;

    // FIXME: We need a beter solution for handling condition codes.
    MachineInstr *ICmp = BuildMI(*BB, &I, DL, TII.get(Opcode))
            .add(I.getOperand(2))
            .add(I.getOperand(3));

    BuildMI(*BB, &I, DL, TII.get(AMDGPU::COPY), I.getOperand(0).getReg())
            .addReg(AMDGPU::SCC);
    MRI.setRegClass(I.getOperand(0).getReg(), &AMDGPU::SReg_32RegClass);
    bool Ret = constrainSelectedInstRegOperands(*ICmp, TII, TRI, RBI);
    I.eraseFromParent();
    return Ret;
  }

  unsigned Opcode = getVALUOpcode(I);
  if (Opcode == AMDGPU::INSTRUCTION_LIST_END)
    return false;
  MachineInstrBuilder Cmp = BuildMI(*BB, &I, DL, TII.get(Opcode),
                                    I.getOperand(0).getReg());

  if (I.getOpcode() == AMDGPU::G_ICMP) {
    Cmp.add(I.getOperand(2))
       .add(I.getOperand(3));
  } else {
    Cmp.addImm(0)
       .add(I.getOperand(2))
       .addImm(0)
       .add(I.getOperand(3))
       .addImm(0)
       .addImm(0);
  }
  RBI.constrainGenericRegister(Cmp->getOperand(0).getReg(),
                               AMDGPU::SReg_64RegClass, MRI);
  bool Ret = constrainSelectedInstRegOperands(*Cmp, TII, TRI, RBI);
  I.eraseFromParent();
  return Ret;
}

bool
AMDGPUInstructionSelector::selectG_INSERT_VECTOR_ELT(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();
  DebugLoc DL = I.getDebugLoc();
  int64_t SubRegIdx;
  if (!isConstant(I.getOperand(3), SubRegIdx))
    return false;
  unsigned DstReg = I.getOperand(0).getReg();

  BuildMI(*BB, &I, DL, TII.get(AMDGPU::INSERT_SUBREG), DstReg)
          .addReg(I.getOperand(1).getReg())
          .addReg(I.getOperand(2).getReg())
          .addImm(AMDGPU::sub0); //SubRegIdx);

  I.eraseFromParent();
  return constrainGenericOpReg(MRI, DstReg);
}

bool
AMDGPUInstructionSelector::selectMIMG(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();

  unsigned Val = I.getOperand(1).getReg();
  unsigned ValSize = RBI.getSizeInBits(Val, MRI, TRI);
  unsigned VAddr = I.getOperand(2).getReg();
  unsigned VAddrSize = RBI.getSizeInBits(VAddr, MRI, TRI);
  unsigned Opcode;

  switch (ValSize) {
  default:
    return false;
  case 128:
    switch (VAddrSize) {
    default:
      return false;
    case 64:
      Opcode = AMDGPU::IMAGE_STORE_V4_V2;
      break;
    }
    break;
  }
}

bool
AMDGPUInstructionSelector::selectMUBUF(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();

  bool IsIntrinsic = I.getOperand(0).isIntrinsicID() ||
                     I.getOperand(1).isIntrinsicID();

  if (!IsIntrinsic)
    return false;

  bool IsStore = I.getOperand(0).isIntrinsicID();
  unsigned IntrinsicID = IsStore ? I.getOperand(0).getIntrinsicID() : 
                                   I.getOperand(1).getIntrinsicID();
  unsigned VData;
  if (IsStore) {
    VData = I.getOperand(1).getReg();
  } else {
    VData = I.getOperand(0).getReg();
  }

  unsigned Rsrc = I.getOperand(2).getReg();
  unsigned VIndex = I.getOperand(3).getReg();
  unsigned Offset = I.getOperand(4).getReg();

  int64_t Glc;
  int64_t Slc;

  if (!isConstant(I.getOperand(5), Glc) ||
      !isConstant(I.getOperand(6), Slc)) {
    return false;
  }

  unsigned VDataSize = RBI.getSizeInBits(VData, MRI, TRI);

  unsigned Opcode = AMDGPU::INSTRUCTION_LIST_END;
  switch (IntrinsicID) {
  default:
    break;
  case Intrinsic::amdgcn_buffer_load:
    if (VDataSize == 32)
      Opcode = AMDGPU::BUFFER_LOAD_DWORD_OFFEN;
    else if (VDataSize == 128)
      Opcode = AMDGPU::BUFFER_LOAD_DWORDX4_OFFEN;
    break;
  case Intrinsic::amdgcn_buffer_load_format:
    if (VDataSize == 32)
      Opcode = AMDGPU::BUFFER_LOAD_FORMAT_X_OFFEN;
    else if (VDataSize == 128)
      Opcode = AMDGPU::BUFFER_LOAD_FORMAT_XYZW_OFFEN;
    break;
  case Intrinsic::amdgcn_buffer_store:
    if (VDataSize == 32)
      Opcode = AMDGPU::BUFFER_STORE_DWORD_OFFEN;
    else if (VDataSize == 64)
      Opcode = AMDGPU::BUFFER_STORE_DWORDX2_OFFEN;
    else if (VDataSize == 128)
      Opcode = AMDGPU::BUFFER_STORE_DWORDX4_OFFEN;
    break;
  case Intrinsic::amdgcn_buffer_store_format:
    if (VDataSize == 32)
      Opcode = AMDGPU::BUFFER_STORE_FORMAT_X_OFFEN;
    else if (VDataSize == 128)
      Opcode = AMDGPU::BUFFER_STORE_FORMAT_XYZW_OFFEN;
    break;
  }

  if (Opcode == AMDGPU::INSTRUCTION_LIST_END)
    return false;

  const MCInstrDesc &Desc = TII.get(Opcode);

  DebugLoc DL = I.getDebugLoc();
  MachineInstrBuilder MUBUF = BuildMI(*BB, &I, DL, Desc);
  if (IsStore)
    MUBUF.addReg(VData);
  else
    MUBUF.addDef(VData);

  MUBUF.addReg(Offset)
       .addReg(Rsrc)
       .addImm(0) // soffset
       .addImm(0) // offset
       .addImm(Glc)
       .addImm(Slc)
       .addImm(0); //tfe
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MUBUF, TII, TRI, RBI);
}

bool AMDGPUInstructionSelector::selectG_INTRINSIC(MachineInstr &I) const {
  unsigned IntrinsicID =  I.getOperand(1).getIntrinsicID();

  switch (IntrinsicID) {
  default: break;
  case Intrinsic::maxnum:
  case Intrinsic::minnum:
  case Intrinsic::rint:
  case Intrinsic::amdgcn_cvt_pkrtz:
  case Intrinsic::amdgcn_image_load_mip:
  case Intrinsic::amdgcn_image_sample:
  case Intrinsic::amdgcn_interp_p1:
  case Intrinsic::amdgcn_interp_p2:
    return selectSimple(I);
  case Intrinsic::amdgcn_buffer_load_format:
  case Intrinsic::amdgcn_buffer_load:
    return selectMUBUF(I);
  } 
  return false;
}

static MachineInstr *
buildEXP(const TargetInstrInfo &TII, MachineInstr *Insert, unsigned Tgt,
         unsigned Reg0, unsigned Reg1, unsigned Reg2, unsigned Reg3,
         unsigned VM, bool Compr, unsigned Enabled, bool Done) {
  DebugLoc DL = Insert->getDebugLoc();
  MachineBasicBlock &BB = *Insert->getParent();
  unsigned Opcode = Done ? AMDGPU::EXP_DONE : AMDGPU::EXP;
  return BuildMI(BB, Insert, DL, TII.get(Opcode))
          .addImm(Tgt)
          .addReg(Reg0)
          .addReg(Reg1)
          .addReg(Reg2)
          .addReg(Reg3)
          .addImm(VM)
          .addImm(Compr)
          .addImm(Enabled);
}

bool AMDGPUInstructionSelector::selectG_INTRINSIC_W_SIDE_EFFECTS(
                                                 MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();
  DebugLoc DL = I.getDebugLoc();

  unsigned IntrinsicID = I.getOperand(0).isIntrinsicID() ?
                        I.getOperand(0).getIntrinsicID() :
                        I.getOperand(1).getIntrinsicID();
  switch (IntrinsicID) {
  case Intrinsic::amdgcn_image_sample:
  case Intrinsic::amdgcn_image_store:
    return selectSimple(I);
  case Intrinsic::amdgcn_buffer_load_format:
  case Intrinsic::amdgcn_buffer_load:
  case Intrinsic::amdgcn_buffer_store:
  case Intrinsic::amdgcn_buffer_store_format:
    return selectMUBUF(I);

  case Intrinsic::amdgcn_end_cf: {
    MachineBasicBlock *BB = I.getParent();
    MachineFunction *MF = BB->getParent();
    MachineRegisterInfo &MRI = MF->getRegInfo();
    const DebugLoc &DL = I.getDebugLoc();

    MachineInstr *New = BuildMI(*BB, &I, DL, TII.get(AMDGPU::SI_END_CF))
                                .add(I.getOperand(0));
    bool Ret = constrainSelectedInstRegOperands(*New, TII, TRI, RBI);
    I.eraseFromParent();
    return Ret;
  }
  case Intrinsic::amdgcn_exp: {
    int64_t Tgt = getConstant(MRI.getVRegDef(I.getOperand(1).getReg()));
    int64_t Enabled = getConstant(MRI.getVRegDef(I.getOperand(2).getReg()));
    int64_t Done = getConstant(MRI.getVRegDef(I.getOperand(7).getReg()));
    int64_t VM = getConstant(MRI.getVRegDef(I.getOperand(8).getReg()));
   
    MachineInstr *Exp = buildEXP(TII, &I, Tgt, I.getOperand(3).getReg(),
                                 I.getOperand(4).getReg(),
                                 I.getOperand(5).getReg(),
                                 I.getOperand(6).getReg(),
                                 VM, false, Enabled, Done);
    
    // operands to use appropriate classes.
    bool Ret = constrainSelectedInstRegOperands(*Exp, TII, TRI, RBI);

    I.eraseFromParent();
    return Ret;
  }
  case Intrinsic::amdgcn_exp_compr: {
    int64_t Tgt = getConstant(MRI.getVRegDef(I.getOperand(1).getReg()));
    int64_t Enabled = getConstant(MRI.getVRegDef(I.getOperand(2).getReg()));
    unsigned Reg0 = I.getOperand(3).getReg();
    unsigned Reg1 = I.getOperand(4).getReg();
    unsigned Undef = MRI.createVirtualRegister(&AMDGPU::VGPR_32RegClass);
    int64_t Done = getConstant(MRI.getVRegDef(I.getOperand(5).getReg()));
    int64_t VM = getConstant(MRI.getVRegDef(I.getOperand(6).getReg()));

    BuildMI(*BB, &I, DL, TII.get(AMDGPU::IMPLICIT_DEF), Undef);
    MachineInstr *Exp = buildEXP(TII, &I, Tgt, Reg0, Reg1, Undef, Undef, VM,
                                 true,  Enabled, Done);
    bool Ret = constrainSelectedInstRegOperands(*Exp, TII, TRI, RBI);

    I.eraseFromParent();
    return Ret;
  }
  }
  return false;
}

bool AMDGPUInstructionSelector::hasOnlySGPROperands(const MachineInstr &I,
                                         const MachineRegisterInfo &MRI) const {
  for (const MachineOperand &MO : I.operands()) {
    if (!MO.isReg())
      continue;
    const RegisterBank *OpBank = RBI.getRegBank(MO.getReg(), MRI, TRI);
    if (OpBank->getID() != AMDGPU::SGPRRegBankID &&
        OpBank->getID() != AMDGPU::SCCRegBankID)
      return false;
  }
  return true;
}

bool AMDGPUInstructionSelector::selectG_SELECT(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();
  DebugLoc DL = I.getDebugLoc();

  unsigned DstReg = I.getOperand(0).getReg();
  unsigned Size = RBI.getSizeInBits(DstReg, MRI, TRI);
  assert(Size == 32 || Size == 64);
  if (hasOnlySGPROperands(I, MRI)) {
    unsigned SelectOpcode = Size == 32 ? AMDGPU::S_CSELECT_B32 :
                                         AMDGPU::S_CSELECT_B64;
    BuildMI(*BB, &I, DL, TII.get(AMDGPU::COPY), AMDGPU::SCC)
            .addReg(I.getOperand(1).getReg());

    MachineInstr *Select = BuildMI(*BB, &I, DL, TII.get(SelectOpcode), DstReg)
            .add(I.getOperand(2))
            .add(I.getOperand(3));

    MRI.setRegClass(I.getOperand(1).getReg(), &AMDGPU::SReg_32RegClass);
    bool Ret = constrainSelectedInstRegOperands(*Select, TII, TRI, RBI);

    I.eraseFromParent();
    return Ret;
  }

  assert(Size == 32);
  // FIXME: Support 64-bit compares
  MachineInstr *Select =
      BuildMI(*BB, &I, DL, TII.get(AMDGPU::V_CNDMASK_B32_e64), DstReg)
              .add(I.getOperand(3))
              .add(I.getOperand(2))
              .add(I.getOperand(1));

  bool Ret = constrainSelectedInstRegOperands(*Select, TII, TRI, RBI);
  I.eraseFromParent();
  return Ret;
}

bool AMDGPUInstructionSelector::selectG_STORE(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  DebugLoc DL = I.getDebugLoc();

  // FIXME: Select store instruction based on address space
  MachineInstr *Flat = BuildMI(*BB, &I, DL, TII.get(AMDGPU::FLAT_STORE_DWORD))
          .add(I.getOperand(1))
          .add(I.getOperand(0))
          .addImm(0)  // offset
          .addImm(0)  // glc
          .addImm(0); // slc


  // Now that we selected an opcode, we need to constrain the register
  // operands to use appropriate classes.
  bool Ret = constrainSelectedInstRegOperands(*Flat, TII, TRI, RBI);

  I.eraseFromParent();
  return Ret;
}

static unsigned getNumExplicitDefs(const MachineInstr &I) {
  unsigned NumDefs = 0;
  for (const MachineOperand &MO : I.explicit_operands()) {
    if (!MO.isReg() || !MO.isDef())
      continue;      
    ++NumDefs;
  }
  return NumDefs;
}

bool AMDGPUInstructionSelector::selectG_UNMERGE_VALUES(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();
  LLVMContext &Ctx = MF->getFunction()->getContext();
  const DebugLoc &DL = I.getDebugLoc();

  SmallVector<MachineInstr*, 8> Insts;

  unsigned DstSize = RBI.getSizeInBits(I.getOperand(0).getReg(), MRI, TRI);
  unsigned NumDefs = getNumExplicitDefs(I);
  unsigned SrcReg = I.getOperand(NumDefs).getReg();
  LLT VecTy = LLT::vector(NumDefs, DstSize);
  unsigned VecReg = MRI.createGenericVirtualRegister(VecTy);
  const RegisterBank *SrcBank = RBI.getRegBank(SrcReg, MRI, TRI);
  if (!SrcBank)
    return false;
  MRI.setRegBank(VecReg, *SrcBank);

  Insts.push_back(BuildMI(*BB, &I, DL, TII.get(AMDGPU::G_BITCAST), VecReg)
                          .addReg(SrcReg));
  dbgs() << "Thre are " << NumDefs << " defs\n";
  for (unsigned i = 0; i < NumDefs; ++i) {
    unsigned IdxReg = MRI.createGenericVirtualRegister(LLT::scalar(32));
    MRI.setRegBank(IdxReg, RBI.getRegBank(AMDGPU::SGPRRegBankID)); 
    const ConstantInt *Idx = ConstantInt::get(IntegerType::get(Ctx, 32), i);
    Insts.push_back(BuildMI(*BB, &I, DL, TII.get(AMDGPU::G_CONSTANT), IdxReg)
                            .addCImm(Idx));
    Insts.push_back(BuildMI(*BB, &I, DL, TII.get(AMDGPU::G_EXTRACT_VECTOR_ELT),
                            I.getOperand(i).getReg())
                            .addReg(VecReg)
                            .addReg(IdxReg));
  }

  I.eraseFromParent();
  dbgs() << "Threre are " << Insts.size() << " insts.\n";
  for (int i = Insts.size() - 1; i >= 0; --i) {
          dbgs() << "i = " << i << " " << *Insts[i] << '\n';
    if (!select(*Insts[i]))
      return false;
  }
  return true;
}

bool AMDGPUInstructionSelector::selectG_CONSTANT(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();
  unsigned DstReg = I.getOperand(0).getReg();
  unsigned Size = RBI.getSizeInBits(DstReg, MRI, TRI);
  const MachineOperand &COp = I.getOperand(1);
  const APInt &Imm = COp.isFPImm() ?
      COp.getFPImm()->getValueAPF().bitcastToAPInt() :
      COp.getCImm()->getValue();
  const RegisterBank *RegBank = RBI.getRegBank(DstReg, MRI, TRI);
  unsigned Opcode = RegBank->getID() == AMDGPU::SGPRRegBankID ?
      AMDGPU::S_MOV_B32 : AMDGPU::V_MOV_B32_e32;
  if (Size == 1)
          Opcode = AMDGPU::S_MOV_B64;

  if (Size == 1 || Size == 16 || Size == 32) {
    I.setDesc(TII.get(Opcode));
    I.getOperand(1).ChangeToImmediate(Imm.getSExtValue());
    I.addImplicitDefUseOperands(*MF);
    return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
  }

  if (Size != 64)
    return false;

  DebugLoc DL = I.getDebugLoc();
  unsigned LoReg = MRI.createVirtualRegister(&AMDGPU::SReg_32RegClass);
  unsigned HiReg = MRI.createVirtualRegister(&AMDGPU::SReg_32RegClass);

  BuildMI(*BB, &I, DL, TII.get(Opcode), LoReg)
          .addImm(Imm.trunc(32).getZExtValue());

  BuildMI(*BB, &I, DL, TII.get(Opcode), HiReg)
          .addImm(Imm.ashr(32).getZExtValue());

  BuildMI(*BB, &I, DL, TII.get(AMDGPU::REG_SEQUENCE), DstReg)
          .addReg(LoReg)
          .addImm(AMDGPU::sub0)
          .addReg(HiReg)
          .addImm(AMDGPU::sub1);
  // We can't call constrainSelectedInstRegOperands here, because it doesn't
  // work for target independent opcodes
  I.eraseFromParent();
  return RBI.constrainGenericRegister(DstReg, AMDGPU::SReg_64RegClass, MRI);
}

static bool isConstant(const MachineInstr &MI) {
  return MI.getOpcode() == TargetOpcode::G_CONSTANT;
}

void AMDGPUInstructionSelector::getAddrModeInfo(const MachineInstr &Load,
    const MachineRegisterInfo &MRI, SmallVectorImpl<GEPInfo> &AddrInfo) const {

  const MachineInstr *PtrMI = MRI.getUniqueVRegDef(Load.getOperand(1).getReg());

  assert(PtrMI);

  if (PtrMI->getOpcode() != TargetOpcode::G_GEP)
    return;

  GEPInfo GEPInfo(*PtrMI);

  for (unsigned i = 1, e = 3; i < e; ++i) {
    const MachineOperand &GEPOp = PtrMI->getOperand(i);
    const MachineInstr *OpDef = MRI.getUniqueVRegDef(GEPOp.getReg());
    assert(OpDef);
    if (isConstant(*OpDef)) {
      // FIXME: Is it possible to have multiple Imm parts?  Maybe if we
      // are lacking other optimizations.
      assert(GEPInfo.Imm == 0);
      GEPInfo.Imm = OpDef->getOperand(1).getCImm()->getSExtValue();
      continue;
    }
    const RegisterBank *OpBank = RBI.getRegBank(GEPOp.getReg(), MRI, TRI);
    if (OpBank->getID() == AMDGPU::SGPRRegBankID)
      GEPInfo.SgprParts.push_back(GEPOp.getReg());
    else
      GEPInfo.VgprParts.push_back(GEPOp.getReg());
  }

  AddrInfo.push_back(GEPInfo);
  getAddrModeInfo(*PtrMI, MRI, AddrInfo);
}

static bool isInstrUniform(const MachineInstr &MI) {
  if (!MI.hasOneMemOperand())
    return false;

  const MachineMemOperand *MMO = *MI.memoperands_begin();
  const Value *Ptr = MMO->getValue();

  // UndefValue means this is a load of a kernel input.  These are uniform.
  // Sometimes LDS instructions have constant pointers.
  // If Ptr is null, then that means this mem operand contains a
  // PseudoSourceValue like GOT.
  if (!Ptr || isa<UndefValue>(Ptr) || isa<Argument>(Ptr) ||
      isa<Constant>(Ptr) || isa<GlobalValue>(Ptr))
    return true;

  const Instruction *I = dyn_cast<Instruction>(Ptr);
  return I && I->getMetadata("amdgpu.uniform");
}

static unsigned getSmrdOpcode(unsigned BaseOpcode, unsigned LoadSize) {

  if (LoadSize == 32)
    return BaseOpcode;

  switch (BaseOpcode) {
  case AMDGPU::S_LOAD_DWORD_IMM:
    switch (LoadSize) {
    case 64:
      return AMDGPU::S_LOAD_DWORDX2_IMM;
    case 128:
      return AMDGPU::S_LOAD_DWORDX4_IMM;
    case 256:
      return AMDGPU::S_LOAD_DWORDX8_IMM;
    case 512:
      return AMDGPU::S_LOAD_DWORDX16_IMM;
    }
    break;
  case AMDGPU::S_LOAD_DWORD_IMM_ci:
    switch (LoadSize) {
    case 64:
      return AMDGPU::S_LOAD_DWORDX2_IMM_ci;
    case 128:
      return AMDGPU::S_LOAD_DWORDX4_IMM_ci;
    case 256:
      return AMDGPU::S_LOAD_DWORDX8_IMM_ci;
    case 512:
      return AMDGPU::S_LOAD_DWORDX16_IMM_ci;
    }
    break;
  case AMDGPU::S_LOAD_DWORD_SGPR:
    switch (LoadSize) {
    case 64:
      return AMDGPU::S_LOAD_DWORDX2_SGPR;
    case 128:
      return AMDGPU::S_LOAD_DWORDX4_SGPR;
    case 256:
      return AMDGPU::S_LOAD_DWORDX8_SGPR;
    case 512:
      return AMDGPU::S_LOAD_DWORDX16_SGPR;
    }
    break;
  }
  llvm_unreachable("Invalid base smrd opcode or size");
}

bool AMDGPUInstructionSelector::hasVgprParts(ArrayRef<GEPInfo> AddrInfo) const {
  for (const GEPInfo &GEPInfo : AddrInfo) {
    if (!GEPInfo.VgprParts.empty())
      return true;
  }
  return false;
}

bool AMDGPUInstructionSelector::selectSMRD(MachineInstr &I,
                                           ArrayRef<GEPInfo> AddrInfo) const {

  if (!I.hasOneMemOperand())
    return false;

  if ((*I.memoperands_begin())->getAddrSpace() != AMDGPUASI.CONSTANT_ADDRESS)
    return false;

  if (!isInstrUniform(I))
    return false;

  if (hasVgprParts(AddrInfo))
    return false;

  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  const SISubtarget &Subtarget = MF->getSubtarget<SISubtarget>();
  MachineRegisterInfo &MRI = MF->getRegInfo();
  unsigned DstReg = I.getOperand(0).getReg();
  const DebugLoc &DL = I.getDebugLoc();
  unsigned Opcode;
  unsigned LoadSize = RBI.getSizeInBits(DstReg, MRI, TRI);

  if (!AddrInfo.empty() && AddrInfo[0].SgprParts.size() == 1) {

    const GEPInfo &GEPInfo = AddrInfo[0];

    unsigned PtrReg = GEPInfo.SgprParts[0];
    int64_t EncodedImm = AMDGPU::getSMRDEncodedOffset(Subtarget, GEPInfo.Imm);
    if (AMDGPU::isLegalSMRDImmOffset(Subtarget, GEPInfo.Imm)) {
      Opcode = getSmrdOpcode(AMDGPU::S_LOAD_DWORD_IMM, LoadSize);

      MachineInstr *SMRD = BuildMI(*BB, &I, DL, TII.get(Opcode), DstReg)
                                 .addReg(PtrReg)
                                 .addImm(EncodedImm)
                                 .addImm(0); // glc
      return constrainSelectedInstRegOperands(*SMRD, TII, TRI, RBI);
    }

    if (Subtarget.getGeneration() == AMDGPUSubtarget::SEA_ISLANDS &&
        isUInt<32>(EncodedImm)) {
      Opcode = getSmrdOpcode(AMDGPU::S_LOAD_DWORD_IMM_ci, LoadSize);
      MachineInstr *SMRD = BuildMI(*BB, &I, DL, TII.get(Opcode), DstReg)
                                   .addReg(PtrReg)
                                   .addImm(EncodedImm)
                                   .addImm(0); // glc
      return constrainSelectedInstRegOperands(*SMRD, TII, TRI, RBI);
    }

    if (isUInt<32>(GEPInfo.Imm)) {
      Opcode = getSmrdOpcode(AMDGPU::S_LOAD_DWORD_SGPR, LoadSize);
      unsigned OffsetReg = MRI.createVirtualRegister(&AMDGPU::SReg_32RegClass);
      BuildMI(*BB, &I, DL, TII.get(AMDGPU::S_MOV_B32), OffsetReg)
              .addImm(GEPInfo.Imm);

      MachineInstr *SMRD = BuildMI(*BB, &I, DL, TII.get(Opcode), DstReg)
                                   .addReg(PtrReg)
                                   .addReg(OffsetReg)
                                   .addImm(0); // glc
      return constrainSelectedInstRegOperands(*SMRD, TII, TRI, RBI);
    }
  }

  unsigned PtrReg = I.getOperand(1).getReg();
  Opcode = getSmrdOpcode(AMDGPU::S_LOAD_DWORD_IMM, LoadSize);
  MachineInstr *SMRD = BuildMI(*BB, &I, DL, TII.get(Opcode), DstReg)
                               .addReg(PtrReg)
                               .addImm(0)
                               .addImm(0); // glc
  return constrainSelectedInstRegOperands(*SMRD, TII, TRI, RBI);
}


bool AMDGPUInstructionSelector::selectG_LOAD(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();
  DebugLoc DL = I.getDebugLoc();
  unsigned DstReg = I.getOperand(0).getReg();
  unsigned PtrReg = I.getOperand(1).getReg();
  unsigned LoadSize = RBI.getSizeInBits(DstReg, MRI, TRI);
  unsigned Opcode;

  SmallVector<GEPInfo, 4> AddrInfo;

  getAddrModeInfo(I, MRI, AddrInfo);

  if (selectSMRD(I, AddrInfo)) {
    I.eraseFromParent();
    return true;
  }

  switch (LoadSize) {
  default:
    llvm_unreachable("Load size not supported\n");
  case 32:
    Opcode = AMDGPU::FLAT_LOAD_DWORD;
    break;
  case 64:
    Opcode = AMDGPU::FLAT_LOAD_DWORDX2;
    break;
  }

  MachineInstr *Flat = BuildMI(*BB, &I, DL, TII.get(Opcode))
                               .add(I.getOperand(0))
                               .addReg(PtrReg)
                               .addImm(0)  // offset
                               .addImm(0)  // glc
                               .addImm(0); // slc

  bool Ret = constrainSelectedInstRegOperands(*Flat, TII, TRI, RBI);
  I.eraseFromParent();
  return Ret;
}

bool AMDGPUInstructionSelector::selectG_MERGE_VALUES(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();
  LLVMContext &Ctx = MF->getFunction()->getContext();
  const DebugLoc &DL = I.getDebugLoc();

  unsigned DstReg = I.getOperand(0).getReg();
  unsigned Src0 = I.getOperand(1).getReg();
  unsigned Src1 = I.getOperand(2).getReg();
  unsigned SizeDst = RBI.getSizeInBits(DstReg, MRI, TRI);
  unsigned Size0 = RBI.getSizeInBits(Src0, MRI, TRI);
  unsigned Size1 = RBI.getSizeInBits(Src1, MRI, TRI);

  if (SizeDst != 32 && Size1 != 16) {
    MachineInstrBuilder RegSeq = BuildMI(*BB, &I, DL,
                                         TII.get(AMDGPU::REG_SEQUENCE), DstReg);

    for (unsigned i = 1, e = I.getNumOperands(); i != e; ++i) {
      RegSeq.addReg(I.getOperand(i).getReg());
      RegSeq.addImm(TRI.getSubRegFromChannel(i - 1));
    }
    I.eraseFromParent();
    return constrainGenericOpReg(MRI, DstReg);
  }

  unsigned Src1Shl = MRI.createGenericVirtualRegister(LLT::scalar(32));
  const RegisterBank *Src1Bank = RBI.getRegBank(Src1, MRI, TRI);
  if (!Src1Bank)
    return false;
  MRI.setRegBank(Src1Shl, *Src1Bank);
  unsigned C16 = MRI.createGenericVirtualRegister(LLT::scalar(32));
  MRI.setRegBank(C16, RBI.getRegBank(AMDGPU::SGPRRegBankID)); 

  SmallVector<MachineInstr*, 8> Insts;
 
  Insts.push_back(BuildMI(*BB, &I, DL, TII.get(AMDGPU::G_CONSTANT), C16)
                  .addCImm(ConstantInt::get(IntegerType::get(Ctx, 32),
                                            16, false)));
  Insts.push_back(BuildMI(*BB, &I, DL, TII.get(TargetOpcode::G_SHL), Src1Shl)
                          .addReg(Src1)
                          .addReg(C16));
  Insts.push_back(BuildMI(*BB, &I, DL, TII.get(TargetOpcode::G_OR), DstReg)
                          .addReg(Src0)
                          .addReg(Src1));
  I.eraseFromParent();
  for (int i = Insts.size() - 1; i >= 0; --i)
    if (!select(*Insts[i]))
      return false;
  return true;
}

bool AMDGPUInstructionSelector::selectG_ZEXT(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();
  const DebugLoc &DL = I.getDebugLoc();

  unsigned SrcReg = I.getOperand(1).getReg();
  unsigned SrcSize = RBI.getSizeInBits(SrcReg, MRI, TRI);
  const RegisterBank *OpBank = RBI.getRegBank(SrcReg, MRI, TRI);

  // FIXME: This should be a legalize step
  if (SrcSize == 1 && OpBank->getID() == AMDGPU::SGPRRegBankID) {
    MachineInstr *New = BuildMI(*BB, &I, DL, TII.get(AMDGPU::V_CNDMASK_B32_e64),
            I.getOperand(0).getReg())
            .addImm(0)
            .addImm(-1)
            .addReg(SrcReg);
    bool Ret = constrainSelectedInstRegOperands(*New, TII, TRI, RBI);
    I.eraseFromParent();
    return Ret;
  }
  return false; 
}

static unsigned getS_CMPOpcode(CmpInst::Predicate P, unsigned Size) {
  // FIXME: VI supports 64-bit comparse.
  if (Size == 32) {
    switch (P) {
    default:
      break;
    case CmpInst::ICMP_NE:
      return AMDGPU::S_CMP_LG_U32;
    case CmpInst::ICMP_EQ:
      return AMDGPU::S_CMP_EQ_U32;
    case CmpInst::ICMP_SGT:
      return AMDGPU::S_CMP_GT_I32;
    case CmpInst::ICMP_SGE:
      return AMDGPU::S_CMP_GE_I32;
    case CmpInst::ICMP_SLT:
      return AMDGPU::S_CMP_LT_I32;
    case CmpInst::ICMP_SLE:
      return AMDGPU::S_CMP_LE_I32;
    case CmpInst::ICMP_UGT:
      return AMDGPU::S_CMP_GT_U32;
    case CmpInst::ICMP_UGE:
      return AMDGPU::S_CMP_GE_U32;
    case CmpInst::ICMP_ULT:
      return AMDGPU::S_CMP_LT_U32;
    case CmpInst::ICMP_ULE:
      return AMDGPU::S_CMP_LE_U32;
    }
  }
  return AMDGPU::INSTRUCTION_LIST_END;
}

unsigned AMDGPUInstructionSelector::getSALUOpcode(const MachineInstr &I) const {
  const MachineBasicBlock *BB = I.getParent();
  const MachineFunction *MF = BB->getParent();
  const MachineRegisterInfo &MRI = MF->getRegInfo();
  unsigned Size0 = RBI.getSizeInBits(I.getOperand(0).getReg(), MRI, TRI);
  switch (I.getOpcode()) {
  default: break;
  case TargetOpcode::G_ADD:
    if (Size0 == 32)
      return AMDGPU::S_ADD_I32;
    break;
  case TargetOpcode::G_AND:
    if (Size0 == 32)
      return AMDGPU::S_AND_B32;
    if (Size0 == 1 || Size0 == 64)
      return AMDGPU::S_AND_B64;
    break;
  case TargetOpcode::G_ICMP: {
    CmpInst::Predicate P = (CmpInst::Predicate)I.getOperand(1).getPredicate();
    unsigned Size2 = RBI.getSizeInBits(I.getOperand(2).getReg(), MRI, TRI);
    return getS_CMPOpcode(P, Size2);
  }
  case TargetOpcode::G_MUL:
    if (Size0 == 32)
      return AMDGPU::S_MUL_I32;
    break;
  case TargetOpcode::G_OR:
    if (Size0 == 32)
      return AMDGPU::S_OR_B32;
    break;
  case TargetOpcode::G_SHL:
    if (Size0 == 32)
      return AMDGPU::S_LSHL_B32;
    break;
  case TargetOpcode::G_XOR:
    if (Size0 == 32)
      return AMDGPU::S_XOR_B32;
    if (Size0 == 1)
      return AMDGPU::S_XOR_B64;
    break;
  }
  return AMDGPU::INSTRUCTION_LIST_END;
}

bool AMDGPUInstructionSelector::selectSimpleSALU(MachineInstr &I) const {
  unsigned Opcode = getSALUOpcode(I);
  if (Opcode == AMDGPU::INSTRUCTION_LIST_END)
    return false;
  I.setDesc(TII.get(Opcode));
  return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
}

static unsigned getV_CMPOpcode(CmpInst::Predicate P, unsigned Size) {
  if (Size == 32) {
    switch (P) {
    default:
      break;
    case CmpInst::ICMP_NE:
      return AMDGPU::V_CMP_NE_U32_e64;
    case CmpInst::ICMP_EQ:
      return AMDGPU::V_CMP_EQ_U32_e64;
    case CmpInst::ICMP_SGT:
      return AMDGPU::V_CMP_GT_I32_e64;
    case CmpInst::ICMP_SGE:
      return AMDGPU::V_CMP_GE_I32_e64;
    case CmpInst::ICMP_SLT:
      return AMDGPU::V_CMP_LT_I32_e64;
    case CmpInst::ICMP_SLE:
      return AMDGPU::V_CMP_LE_I32_e64;
    case CmpInst::ICMP_UGT:
      return AMDGPU::V_CMP_GT_U32_e64;
    case CmpInst::ICMP_UGE:
      return AMDGPU::V_CMP_GE_U32_e64;
    case CmpInst::ICMP_ULT:
      return AMDGPU::V_CMP_LT_U32_e64;
    case CmpInst::ICMP_ULE:
      return AMDGPU::V_CMP_LE_U32_e64;
    case CmpInst::FCMP_OEQ:
      return AMDGPU::V_CMP_EQ_F32_e64;
    case CmpInst::FCMP_OGT:
      return AMDGPU::V_CMP_GT_F32_e64;
    case CmpInst::FCMP_OGE:
      return AMDGPU::V_CMP_GE_F32_e64;
    case CmpInst::FCMP_OLT:
      return AMDGPU::V_CMP_LT_F32_e64;
    case CmpInst::FCMP_OLE:
      return AMDGPU::V_CMP_LE_F32_e64;
    case CmpInst::FCMP_ONE:
      return AMDGPU::V_CMP_LG_F32_e64;
    case CmpInst::FCMP_ORD:
      return AMDGPU::V_CMP_O_F32_e64;
    case CmpInst::FCMP_UNO:
      return AMDGPU::V_CMP_U_F32_e64;
    case CmpInst::FCMP_UEQ:
      return AMDGPU::V_CMP_NLG_F32_e64;
    case CmpInst::FCMP_UGT:
      return AMDGPU::V_CMP_NLE_F32_e64;
    case CmpInst::FCMP_UGE:
      return AMDGPU::V_CMP_NLT_F32_e64;
    case CmpInst::FCMP_ULT:
      return AMDGPU::V_CMP_NGE_F32_e64;
    case CmpInst::FCMP_ULE:
      return AMDGPU::V_CMP_NGT_F32_e64;
    case CmpInst::FCMP_UNE:
      return AMDGPU::V_CMP_NEQ_F32_e64;
    }
  }
  return AMDGPU::INSTRUCTION_LIST_END;
}

static unsigned getMIMGOpcode(unsigned Intrinsic, unsigned DstSize,
                              unsigned SrcSize) {
  switch (Intrinsic) {
  default:
    break;
  case Intrinsic::amdgcn_image_sample:
    if (DstSize == 128 && SrcSize == 128)
      return AMDGPU::IMAGE_SAMPLE_V4_V4;
    if (DstSize == 128 && SrcSize == 64)
      return AMDGPU::IMAGE_SAMPLE_V4_V2;
    if (DstSize == 32 && SrcSize == 64)
      return AMDGPU::IMAGE_SAMPLE_V1_V2;
    if (DstSize == 32 && SrcSize == 128)
      return AMDGPU::IMAGE_SAMPLE_V1_V4;
    break;
  case Intrinsic::amdgcn_image_store:
    if (DstSize == 128 && SrcSize == 64)
      return AMDGPU::IMAGE_STORE_V4_V2;
  case Intrinsic::amdgcn_image_load_mip:
    if (DstSize == 128 && SrcSize == 128)
      return AMDGPU::IMAGE_LOAD_MIP_V4_V4;
    break;
  }
  return AMDGPU::INSTRUCTION_LIST_END;
}

unsigned AMDGPUInstructionSelector::getVALUOpcode(const MachineInstr &I) const {
  const MachineBasicBlock *BB = I.getParent();
  const MachineFunction *MF = BB->getParent();
  const MachineRegisterInfo &MRI = MF->getRegInfo();
  unsigned Size0 = I.getOperand(0).isReg() ? RBI.getSizeInBits(I.getOperand(0).getReg(), MRI, TRI) : 0;
  switch (I.getOpcode()) {
  default: break;
  case TargetOpcode::G_INTRINSIC:
    switch (I.getOperand(1).getIntrinsicID()) {
      default: break;
      case Intrinsic::amdgcn_cvt_pkrtz:
        return AMDGPU::V_CVT_PKRTZ_F16_F32_e64; 
      case Intrinsic::amdgcn_image_load_mip:
        return getMIMGOpcode(I.getOperand(1).getIntrinsicID(), Size0, RBI.getSizeInBits(I.getOperand(2).getReg(), MRI, TRI));
      case Intrinsic::amdgcn_image_sample:
        return getMIMGOpcode(I.getOperand(1).getIntrinsicID(), Size0, RBI.getSizeInBits(I.getOperand(2).getReg(), MRI, TRI));
      case Intrinsic::amdgcn_interp_p1:
        return AMDGPU::V_INTERP_P1_F32;
      case Intrinsic::amdgcn_interp_p2:
        return AMDGPU::V_INTERP_P2_F32;
      case Intrinsic::maxnum:
        return AMDGPU::V_MAX_F32_e64; 
      case Intrinsic::minnum:
        return AMDGPU::V_MIN_F32_e64; 
      case Intrinsic::rint:
        if (Size0 == 32)
          return AMDGPU::V_RNDNE_F32_e64;
        break;
    }
    break;
  case TargetOpcode::G_INTRINSIC_W_SIDE_EFFECTS: {
    unsigned IntrinsicID = I.getOperand(0).isIntrinsicID() ?
                         I.getOperand(0).getIntrinsicID() :
                         I.getOperand(1).getIntrinsicID();
    switch (IntrinsicID) {
      default:
        break;
      case Intrinsic::amdgcn_image_store:
        return getMIMGOpcode(I.getOperand(0).getIntrinsicID(), RBI.getSizeInBits(I.getOperand(1).getReg(), MRI, TRI), RBI.getSizeInBits(I.getOperand(2).getReg(), MRI, TRI));
      case Intrinsic::amdgcn_image_sample:
        return getMIMGOpcode(I.getOperand(1).getIntrinsicID(), Size0, RBI.getSizeInBits(I.getOperand(2).getReg(), MRI, TRI));
    }
    break;
  }
  case TargetOpcode::G_ADD:
    if (Size0 == 32)
      return AMDGPU::V_ADD_I32_e32;
    break;
  case TargetOpcode::G_AND:
    if (Size0 == 32)
      return AMDGPU::V_AND_B32_e64;
    break;
  case TargetOpcode::G_FADD:
    if (Size0 == 32)
      return AMDGPU::V_ADD_F32_e64;
    break;
  case TargetOpcode::G_FMUL:
    if (Size0 == 32)
      return AMDGPU::V_MUL_F32_e64;
    break;
  case TargetOpcode::G_FPTOSI:
    if (Size0 == 32 &&
        RBI.getSizeInBits(I.getOperand(1).getReg(), MRI, TRI) == 32)
      return AMDGPU::V_CVT_I32_F32_e64;
    break;
  case TargetOpcode::G_FPTOUI:
    if (Size0 == 32 &&
        RBI.getSizeInBits(I.getOperand(1).getReg(), MRI, TRI) == 32)
      return AMDGPU::V_CVT_U32_F32_e64;
    break;
  case TargetOpcode::G_FCMP:
  case TargetOpcode::G_ICMP: {
    CmpInst::Predicate P = (CmpInst::Predicate)I.getOperand(1).getPredicate();
    unsigned Size2 = RBI.getSizeInBits(I.getOperand(2).getReg(), MRI, TRI);
    return getV_CMPOpcode(P, Size2);
  }
  case TargetOpcode::G_MUL:
    if (Size0 == 32)
      return AMDGPU::V_MUL_LO_I32;
  case TargetOpcode::G_OR:
    if (Size0 == 32)
      return AMDGPU::V_OR_B32_e64;
    break;
  case TargetOpcode::G_SHL:
    if (Size0 == 32)
      return AMDGPU::V_LSHL_B32_e64;
    break;
  case TargetOpcode::G_XOR:
    if (Size0 == 32)
      return AMDGPU::V_XOR_B32_e64;
    break;
  }
  return AMDGPU::INSTRUCTION_LIST_END;
}

bool AMDGPUInstructionSelector::selectSimpleVALU(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  const DebugLoc &DL = I.getDebugLoc();
  unsigned Opcode = getVALUOpcode(I);
  if (Opcode == AMDGPU::INSTRUCTION_LIST_END)
    return false;

  const MCInstrDesc &Desc = TII.get(Opcode);
  unsigned OpIdx = 0;
  if (I.getOperand(OpIdx).isIntrinsicID())
    ++OpIdx;
  MachineInstrBuilder VALU =
      BuildMI(*BB, &I, DL, Desc, I.getOperand(OpIdx++).getReg());

  if (I.getOperand(OpIdx).isIntrinsicID())
    ++OpIdx;

  for (unsigned i = 1, e = Desc.NumOperands; i != e; ++i) {
    if (Desc.OpInfo[i].RegClass != -1) {
      VALU.addReg(I.getOperand(OpIdx++).getReg());
      continue;
    }
    // Input / Output modifiers
    VALU.addImm(0);
  }
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*VALU, TII, TRI, RBI);
}

bool AMDGPUInstructionSelector::selectSimple(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();

  const RegisterBank *OpBank = nullptr;
 
  if (I.getOperand(0).isReg())
    OpBank = RBI.getRegBank(I.getOperand(0).getReg(),
                                              MRI, TRI);
  if (OpBank && OpBank->getID() == AMDGPU::SGPRRegBankID)
    return selectSimpleSALU(I);

  return selectSimpleVALU(I);
}

bool AMDGPUInstructionSelector::select(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  MachineFunction *MF = BB->getParent();
  MachineRegisterInfo &MRI = MF->getRegInfo();

  if (!isPreISelGenericOpcode(I.getOpcode())) {
    if (I.isCopy())
      return selectCOPY(I);
    if (I.getOpcode() == TargetOpcode::IMPLICIT_DEF)
      return constrainGenericOpReg(MRI, I.getOperand(0).getReg());
    return true;
  }

  switch (I.getOpcode()) {
  default:
    break;
  case TargetOpcode::G_AND:
  case TargetOpcode::G_FADD:
  case TargetOpcode::G_FMUL:
  case TargetOpcode::G_FPTOSI:
  case TargetOpcode::G_FPTOUI:
  case TargetOpcode::G_MUL:
  case TargetOpcode::G_OR:
  case TargetOpcode::G_SHL:
  case TargetOpcode::G_XOR:
    return selectSimple(I);
  case TargetOpcode::G_ADD:
    return selectG_ADD(I);
  case TargetOpcode::G_ASHR:
    return selectG_ASHR(I);
  case TargetOpcode::G_BITCAST:
    return selectCOPY(I);
  case TargetOpcode::G_BR:
    return selectG_BR(I);
  case TargetOpcode::G_BRCOND:
    return selectG_BRCOND(I);
  case TargetOpcode::G_CONSTANT:
  case TargetOpcode::G_FCONSTANT:
    return selectG_CONSTANT(I);
  case TargetOpcode::G_EXTRACT_VECTOR_ELT:
    return selectG_EXTRACT_VECTOR_ELT(I);
  case TargetOpcode::G_GEP:
    return selectG_GEP(I);
  case TargetOpcode::G_FCMP:
  case TargetOpcode::G_ICMP:
    return selectG_ICMP(I);
  case TargetOpcode::G_INSERT_VECTOR_ELT:
    return selectG_INSERT_VECTOR_ELT(I);
  case TargetOpcode::G_INTRINSIC:
    return selectG_INTRINSIC(I);
  case TargetOpcode::G_INTRINSIC_W_SIDE_EFFECTS:
    return selectG_INTRINSIC_W_SIDE_EFFECTS(I);
  case TargetOpcode::G_LOAD:
    return selectG_LOAD(I);
  case TargetOpcode::G_MERGE_VALUES:
    // FIXME: We should legalize this, but global-isel currently forces these
    // to be legal.
    return selectG_MERGE_VALUES(I);
  case TargetOpcode::G_SELECT:
    return selectG_SELECT(I);
  case TargetOpcode::G_STORE:
    return selectG_STORE(I);
    // FIXME: We should legalize this, but global-isel currently forces these
    // to be legal.
  case TargetOpcode::G_UNMERGE_VALUES:
    return selectG_UNMERGE_VALUES(I);
  case TargetOpcode::G_ZEXT:
    return selectG_ZEXT(I);
  }
  return false;
}
